# 乐拍视界 (LePai Vision) · 客户端开发指南

**版本**: v1.0
**适用框架**: Qt 6.9 / QML / C++
**最后更新**: 2026-01-09

---

## 1. 必读：分布式网络架构认知

在乐拍视界的架构中，客户端不再只与一台服务器交互，而是面对一个**微服务集群**。你必须明确区分以下三个角色的职责与地址：

| 角色 | 别名 | 职责 | 协议 | 端口 | 交互场景 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **API 网关** | PC-2 | 业务大脑 | HTTP (JSON) | **8000** | 登录、注册、获取列表、提交发布信令 |
| **存储中心** | PC-1 | 数据仓库 | HTTP (PUT) | **9000** | **上传**原始视频文件 (直连 MinIO) |
| **CDN 节点** | PC-3 | 内容分发 | HTTP (HLS) | **8001** | **播放**视频流 (.m3u8)、加载封面图 |

> **致命警告**：
> 不要尝试把视频文件发给 API 网关（PC-2）！网关只处理轻量级 JSON 数据，不处理大文件 IO。

---

## 2. 工程配置规范

### 2.1 配置文件 (`config.json`)
禁止硬编码 IP。请在 `main.cpp` 启动时读取 `assets/config.json`，并注入到 `ConfigManager` 单例中。

```json
{
    "api_base_url": "http://192.168.1.100:8000",   // 指向 PC-2 (API)
    "upload_base_url": "http://192.168.1.101:9000", // 指向 PC-1 (MinIO)
    "cdn_base_url": "http://192.168.1.102:8001"     // 指向 PC-3 (CDN)
}
```

### 2.2 网络模块封装建议
建议封装单例 `NetworkManager`，底层使用 `QNetworkAccessManager`。
*   **并发设置**: 视频流和图片加载会自动管理，但 API 请求建议开启 HTTP/2 支持（Qt6 默认支持）。
*   **线程安全**: `QNetworkAccessManager` 必须在**创建它的线程**（通常是主线程）中使用，不要跨线程移动它。

---

## 3. 鉴权机制 (Authorization)

### 3.1 Token 机制
我们使用 **Bearer Token** 机制。
*   **生命周期**: 登录获取 -> 本地存储 -> 请求携带 -> 401失效 -> 重新登录。
*   **格式**: UUID 字符串。

### 3.2 客户端实现
所有发往 **API 网关 (PC-2)** 的请求（除登录注册外），Header 必须包含：

```cpp
// C++ 示例
QNetworkRequest request(url);
request.setRawHeader("Content-Type", "application/json");

// 获取保存的 Token
QString token = ConfigManager::instance().getToken(); 
if (!token.isEmpty()) {
    // 格式必须是 "Bearer " + token，注意中间的空格
    request.setRawHeader("Authorization", QString("Bearer %1").arg(token).toUtf8());
}
```

---

## 4. 核心业务交互详解

### 4.1 用户认证 (User Auth)

#### [POST] `/api/user/login`
*   **目的**: 获取身份令牌。
*   **请求体**:
    ```json
    { "username": "lan", "password": "password123" }
    ```
*   **成功响应 (200)**:
    ```json
    {
        "code": 200,
        "message": "Login successful",
        "token": "550e8400-e29b-...", // [关键] 存入 QSettings 或 SQLite
        "user": { ... }
    }
    ```
*   **失败响应**: 400 (参数错) 或 401 (密码错)。

---

### 4.2 视频上传发布 (双步走策略)

这是最复杂的环节，请严格遵循 **"红蓝线分离"** 策略。

#### **第一步：直传原始文件 (To MinIO)**
客户端直接将文件 PUT 到 MinIO 的临时桶，不经过 API 服务。

*   **URL**: `upload_base_url` + `/temp/` + `uuid.mp4`
    *   *注意*: 文件名建议客户端生成 UUID，防止覆盖。
*   **Method**: `PUT`
*   **Header**: `Content-Type: video/mp4`
*   **Body**: 文件的二进制流 (Binary Raw Data)，**不是** Multipart/form-data！

**Qt 实现参考**:
```cpp
QFile *file = new QFile("path/to/video.mp4");
file->open(QIODevice::ReadOnly);

// 目标地址: http://PC-1:9000/temp/unique_id.mp4
QUrl targetUrl = ConfigManager::instance().getUploadUrl("/temp/" + uuid + ".mp4");
QNetworkRequest req(targetUrl);
req.setRawHeader("Content-Type", "video/mp4");

// 使用 put 上传流
QNetworkReply *reply = manager->put(req, file);

// 监听上传进度
connect(reply, &QNetworkReply::uploadProgress, [](qint64 sent, qint64 total){
    qDebug() << "Progress:" << sent << "/" << total;
});
```

#### **第二步：提交发布信令 (To API)**
只有当第一步的 `reply` 返回 `Finished` 且 `error() == NoError` 时，才执行此步。

*   **URL**: `api_base_url` + `/api/video/publish`
*   **Method**: `POST`
*   **Header**: 需要 Token。
*   **Body**:
    ```json
    {
        "title": "我的旅行Vlog",
        // 这里填第一步上传使用的完整 URL
        "url": "http://192.168.1.101:9000/temp/unique_id.mp4" 
    }
    ```
*   **后续**: 服务端返回 200 即表示**受理成功**。
    *   *注意*: 此时视频进入**转码队列**，不会立即出现在首页。客户端应提示用户“视频处理中，稍后上架”。

---

### 4.3 视频流与无限加载 (Feed & HLS)

服务端采用了流式媒体技术，视频地址不再是 `.mp4`，而是 `.m3u8`。

#### [GET] `/api/feed/discovery`
*   **参数**: 
    *   `limit`: 每次拉取数量 (推荐 10)。
    *   `offset`: 偏移量 (初次为 0)。
*   **逻辑 (无限循环)**:
    服务端实现了自动回滚策略。如果数据库只有 5 个视频，你请求 `offset=10`，服务端会自动返回 `offset=0` 的数据。
    
*   **响应数据 (重点分析)**:
    ```json
    {
        "code": 200,
        "next_offset": 10,  // [关键] 下一次请求用这个值。如果为 0，说明发生回滚，需重置客户端列表。
        "data": [
            {
                "id": "vid-001",
                "title": "HLS 测试视频",
                // [关键] 播放地址指向 CDN，且是 m3u8 格式
                "url": "http://192.168.1.102:8001/public/videos/vid-001/index.m3u8",
                "cover_url": "http://192.168.1.102:8001/public/covers/vid-001.jpg",
                "author": "lan",
                "is_liked": true // 只有登录并携带 Token 才会准确，否则为 false
            }
        ]
    }
    ```

#### **客户端处理逻辑 (伪代码)**
```cpp
void loadMore() {
    if (isLoading) return;
    
    // 发送请求: offset = currentOffset
    api->getFeed(10, currentOffset, [=](Response res) {
        if (res.isSuccess) {
            // 如果服务端说 next_offset 为 0，说明列表循环了/重置了
            if (res.next_offset == 0 && currentOffset != 0) {
                 // 策略A: 清空列表重新加载 (显得像是刷新)
                 // 策略B: 仅仅把数据追加到尾部 (无限流体验) -> 推荐
            }
            
            // 追加数据到 Model
            myModel->append(res.data);
            
            // 更新偏移量
            currentOffset = res.next_offset;
        }
    });
}
```

---

## 5. QML 播放器集成指南

由于使用了 HLS (`.m3u8`)，Qt Multimedia 的后端选择至关重要。

### 5.1 环境要求
*   **Linux/Windows**: 确保系统安装了 `FFmpeg` 或 `GStreamer` 插件。Qt6 通常自带了 ffmpeg 后端。
*   **验证**: 如果播放失败，请先用 VLC 播放器尝试打开那个 `.m3u8` URL。如果 VLC 能放，说明是 Qt 环境问题；如果 VLC 不能放，说明服务端转码失败或网络不通。

### 5.2 QML 代码
```qml
import QtMultimedia

Video {
    id: player
    source: model.url // "http://.../index.m3u8"
    autoPlay: true
    focus: true
    
    // 循环播放单条视频
    loops: MediaPlayer.Infinite 

    onErrorOccurred: {
        console.log("播放出错: " + errorString)
        // 常见错误：ResourceError (网络不通), FormatError (解码器缺失)
    }
}
```

---

## 6. 常见错误速查表 (Troubleshooting)

| 现象 | HTTP状态码 | 可能原因 | 解决方案 |
| :--- | :--- | :--- | :--- |
| **登录失败** | 400 | JSON 格式错误 | 检查 `Content-Type` 是否为 `application/json` |
| **Token 无效** | 401 | Token 过期或被顶号 | **必须**跳转回登录页，清除本地 Token |
| **上传失败** | 403 | MinIO 拒绝访问 | 也就是 PC-1 没跑 `setup_minio_buckets.sh`，Temp 桶不存在 |
| **上传失败** | 0 / NetworkError | 连不上 MinIO | 检查 `config.json` 里 `upload_base_url` 的 IP 是否正确 |
| **视频无法播放** | 200 (但黑屏) | 缺少解码器 | 客户端机器没装 ffmpeg，或网络无法连接 CDN 端口 (8001) |
| **列表为空** | 200 | 数据库没数据 | 正常现象，先去上传一个视频，等几秒转码完成 |

---

## 7. 联调“潜规则”

1.  **心跳检测**: 在开发阶段，建议先用 `ping` 命令测试能不能通 PC-1, PC-2, PC-3 的 IP。
2.  **转码延迟**: 上传完视频后，**不要**立刻去刷新列表，因为 Worker 还在转码。通常需要等待 5-10 秒。
3.  **日志**: 遇到问题，先看 API 返回的 `message` 字段。如果返回 500，请后端开发查阅 `server_log`。