# 乐拍视界 (LePai Vision) · 客户端开发指南

**版本**: v1.0
**适用框架**: Qt 6.5+ / QML / C++17
**架构模式**: MVVM (Model-View-ViewModel)

---

## 1. 必读：分布式网络架构认知

在乐拍视界的架构中，客户端不再只与一台服务器交互，而是面对一个**微服务集群**。你必须明确区分以下三个角色的职责与地址：

| 角色 | 别名 | 职责 | 协议 | 端口 | 交互场景 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **API 网关** | PC-2 | **业务大脑** | HTTP/1.1 (JSON) | **8000** | 登录、注册、获取列表、提交发布信令 |
| **存储中心** | PC-1 | **数据仓库** | HTTP/1.1 (PUT) | **9000** | **上传**原始视频文件 (直连 MinIO) |
| **CDN 节点** | PC-3 | **内容分发** | HTTP (HLS Stream) | **8001** | **播放**视频流 (.m3u8)、加载封面图 |

> **⚠️ 警告**：客户端**严禁**尝试直接连接 PostgreSQL 或 Redis。所有数据操作必须通过 API 网关进行。

---

## 2. 工程配置与基础设施

### 2.1 配置文件 (`config.json`)
禁止将 IP 地址硬编码在 C++ 代码中。程序启动时应读取运行目录下的 `config.json`。

**推荐单例**: `ConfigManager`
```cpp
// 伪代码示例
QString apiBase = ConfigManager::instance().getApiBase(); // 返回 "http://192.168.1.X:8000"
```

### 2.2 网络层封装 (`NetworkClient`)
建议封装一个单例 `NetworkClient`，统一管理 `QNetworkAccessManager`。

*   **并发管理**: `QNetworkAccessManager` 是异步非阻塞的，一个应用程序建议只保留**一个**实例。
*   **统一拦截器**: 在发送请求前统一注入 Header（如 Token），在接收响应后统一检查 `401 Unauthorized`。

---

## 3. 核心业务交互详解

### 3.1 鉴权机制 (Auth Flow)

我们使用 **Bearer Token** 机制。

1.  **登录**: 调用 `/api/user/login` 换取 Token。
2.  **持久化**: 将 Token 存入 `QSettings` (Windows 注册表/ini) 或 SQLite。
3.  **使用**: 每次请求 API 网关时，Header 必须携带：
    ```text
    Authorization: Bearer <Your-UUID-Token>
    ```

**Qt 统一注入示例**:
```cpp
void NetworkClient::attachAuthHeader(QNetworkRequest &req) {
    QString token = ConfigManager::instance().getToken();
    if (!token.isEmpty()) {
        req.setRawHeader("Authorization", QString("Bearer %1").arg(token).toUtf8());
    }
}
```

### 3.2 视频发布 (Upload Pipeline) - **高风险环节**

请严格遵循 **"红蓝线分离"** 策略，分为两步。

#### **阶段一：直传原始文件 (MinIO)**
客户端直接将文件二进制流 PUT 到 MinIO，**不经过 API 服务**。

*   **URL**: `upload_base_url` + `/temp/` + `{ClientGeneratedUUID}.mp4`
    *   *ClientGeneratedUUID*: 客户端使用 `QUuid::createUuid()` 生成，确保不重名。
*   **Method**: `PUT`
*   **Header**: `Content-Type: video/mp4` (不要用 multipart/form-data!)
*   **Body**: 文件二进制流。

**C++ 实现关键点**:
```cpp
// 1. 打开文件
QFile *file = new QFile(filePath);
if (!file->open(QIODevice::ReadOnly)) return;

// 2. 构建 Request
QUrl url(QString("%1/temp/%2.mp4").arg(uploadBaseUrl, uuid));
QNetworkRequest req(url);
req.setHeader(QNetworkRequest::ContentTypeHeader, "video/mp4"); // 必须指定

// 3. 执行 PUT (Qt 会自动处理流式上传，不会一次性占满内存)
QNetworkReply *reply = manager->put(req, file);

// 4. 必须管理 file 的生命周期，上传完才能关
connect(reply, &QNetworkReply::finished, [file, reply](){
    file->close();
    file->deleteLater();
    reply->deleteLater();
    // 检查 reply->error() ...
});
```

#### **阶段二：提交发布信令 (API)**
只有当阶段一成功（HTTP 200 OK）后，才向 API 发送指令。

*   **URL**: `/api/video/publish`
*   **Method**: `POST`
*   **Body**:
    ```json
    {
        "title": "我的Qt大作",
        // 注意：这里填的是阶段一上传的【完整 MinIO URL】
        // 如: http://192.168.1.101:9000/temp/abc-123.mp4
        "url": "http://192.168.1.101:9000/temp/..." 
    }
    ```

> **用户体验优化**: 此时服务器开始异步转码。客户端应弹出 Toast 提示：“视频发布中，请稍候...”，并关闭发布页。

---

### 3.3 沉浸式视频流 (Infinite Feed)

#### [GET] `/api/feed/discovery`
*   **策略**: 采用了类似抖音的无限流，但后端数据有限时会**循环**。
*   **关键参数**: `limit=10`, `offset=0` (初始值)。

**响应处理逻辑**:
```cpp
// 假设这是在 ViewModel 中
void FeedViewModel::handleResponse(const QJsonObject &json) {
    int nextOffset = json["next_offset"].toInt();
    QJsonArray videos = json["data"].toArray();

    if (videos.isEmpty()) return;

    // 1. 如果 offset 回归 0，且当前列表不为空，说明后端数据循环了
    // 策略：为了“无限下滑”的体验，不要清空列表，直接 Append 数据
    // 这样用户感觉不到列表到底了。
    
    // 2. 将数据转换为 C++ 对象插入 Model
    beginInsertRows(..., m_videos.count(), m_videos.count() + videos.size() - 1);
    for (const auto &v : videos) {
        m_videos.append(parseVideo(v));
    }
    endInsertRows();

    // 3. 更新下一次请求的 offset
    m_currentOffset = nextOffset;
}
```

---

## 4. QML & Multimedia 集成 (Qt 6 特别版)

Qt 6 重构了 Multimedia 模块，与 Qt 5 差异巨大。

### 4.1 播放器组件
推荐使用 `MediaPlayer` + `VideoOutput` 的组合，比 `Video` 组件更可控。

```qml
import QtQuick
import QtMultimedia

Item {
    id: videoRoot
    
    MediaPlayer {
        id: player
        // 指向 CDN 地址 (http://PC-3:8001/public/videos/.../index.m3u8)
        source: model.url 
        
        videoOutput: videoOut
        audioOutput: AudioOutput {}

        // 自动循环播放
        loops: MediaPlayer.Infinite
    }

    VideoOutput {
        id: videoOut
        anchors.fill: parent
        fillMode: VideoOutput.PreserveAspectCrop // 抖音风格：裁切充满
    }
    
    // 封面图处理：视频加载前显示封面，播放后隐藏
    Image {
        id: coverImg
        anchors.fill: parent
        source: model.cover_url
        fillMode: Image.PreserveAspectCrop
        visible: player.playbackState !== MediaPlayer.PlayingState
    }
    
    // 列表滑动优化：当前 Item 不可见时，停止播放节省资源
    Component.onCompleted: {
        if (ListView.isCurrentItem) player.play()
    }
    // 监听 ListView 的当前项变化（需要在外层逻辑实现）
}
```

### 4.2 HLS 播放依赖
Qt 6 Multimedia 默认依赖宿主机的解码能力。
*   **Windows**: 需要安装 LAV Filters 或确保系统支持 H.264。
*   **Linux**: 必须安装 `ffmpeg`, `gstreamer-plugins-bad`, `gstreamer-plugins-ugly`, `libavcodec`。
    *   *测试命令*: 在终端运行 `ffplay http://PC-3:8001/.../index.m3u8` 确保能播放。

---

## 5. 常见问题 (Troubleshooting)

| 现象 | 错误代码 | 根源分析 | 解决方案 |
| :--- | :--- | :--- | :--- |
| **Login 400** | BadRequest | JSON 格式错误 | 检查 Request Header 是否设置 `Content-Type: application/json` |
| **Upload 403** | Forbidden | MinIO 权限拒绝 | 检查 PC-1 是否运行了 `setup_minio_buckets.sh`，且 bucket 策略正确 |
| **Upload 0** | ConnectionRefused | 连不上 MinIO | 检查 `config.json` 中上传地址 IP 是否是 PC-1 的局域网 IP |
| **播放黑屏** | 200 OK | 解码器缺失 | Qt6 在 Linux 下极度依赖 GStreamer 和 FFmpeg 库，请补全系统依赖 |
| **没有封面图** | 404 Not Found | 转码未完成 | 上传后 FFmpeg 需要时间生成截图。转码是异步的，刚传完可能还没图。 |
| **Token 失效** | 401 Unauthorized | 异地登录/过期 | 网络层必须捕获 401，发出信号强制跳转回登录页，并清空本地 Token |

---

## 6. 开发建议

1.  **心跳检测**: 
    在开发机上，先用浏览器或 `curl` 分别访问三个端口：
    *   `http://PC-2:8000/` (Nginx/API)
    *   `http://PC-1:9000/minio/health/live` (MinIO)
    *   `http://PC-3:8001/` (CDN)
    确保网络通畅再运行代码。

2.  **转码延迟**: 
    视频上传后，服务端会有 **5-10秒** 的转码延迟。客户端发布成功后，建议给用户一个“处理中”的反馈，不要立即刷新列表期待看到视频。

3.  **日志调试**:
    开启 Qt 网络日志以便调试：
    ```bash
    export QT_LOGGING_RULES="qt.network.*=true"
    ```