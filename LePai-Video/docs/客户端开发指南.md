# 乐拍视界 (LePai Vision) · 客户端开发指南

**适用版本**: Server v1.0 | **框架**: Qt 6.5+ (QML/C++) | **架构**: 分布式物理集群

---

## 1. 物理拓扑与网络配置 (Network Topology)

客户端**必须**同时与三个不同的物理节点交互。请在 `ConfigManager` 中加载 `config.json`，严禁硬编码 IP。

| 节点角色 | 别名 | 协议 | 端口 | Base URL 示例 | 核心职责 | 交互特点 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **业务网关** | **PC-2** | HTTP | **8000** | `http://192.168.1.11:8000` | 用户、社交、元数据 | 高频、小包 JSON 数据 |
| **源站存储** | **PC-1** | HTTP | **9000** | `http://192.168.1.10:9000` | **仅用于**视频上传 | 低频、大文件 PUT 请求 |
| **CDN 加速** | **PC-3** | HTTP | **8001** | `http://192.168.1.12:8001` | 图片加载、视频播放 | 只读、长连接、大流量 |

### 1.1 `config.json` 模板
```json
{
    "api_base": "http://192.168.1.11:8000",
    "upload_base": "http://192.168.1.10:9000", 
    "cdn_base": "http://192.168.1.12:8001"
}
```

---

## 2. 通用交互规范 (Protocol Specs)

### 2.1 请求头 (Headers)管理
*   **Content-Type**:
    *   API 请求: `application/json`
    *   视频上传: `video/mp4` (注意是 Raw Binary，不是 Multipart)
    *   头像上传: `multipart/form-data`
*   **Authorization**:
    *   除注册/登录/发现流外，建议所有请求都带上 Token。
    *   格式: `Authorization: Bearer <uuid-token>`

### 2.2 统一响应结构
服务端所有 API (PC-2) 返回统一的 JSON 包壳：

```json
// 成功
{
    "code": 200,
    "message": "success",
    "data": { ... } // 具体业务数据
}

// 失败
{
    "code": 401, // 401=未登录, 400=参数错, 500=服务端崩
    "message": "Token expired"
}
```

---

## 3. 核心业务流程详解

### 3.1 认证模块 (Auth Module)

#### A. 注册 (Register)
*   **URL**: `POST /api/user/register`
*   **Body**: `{ "username": "...", "password": "..." }`
*   **Response**: `200 OK` (注册成功后需自动跳转登录页，或自动执行登录)

#### B. 登录 (Login)
*   **URL**: `POST /api/user/login`
*   **Body**: `{ "username": "...", "password": "..." }`
*   **Response**:
    ```json
    {
        "code": 200,
        "token": "550e8400-e29b-...", // 存入 UserContext
        "user": {                      // 存入 UserContext 用于显示我的信息
            "id": "u1",
            "username": "Jack",
            "avatar_url": "http://PC-3:8001/public/defaults/default.png",
            "following_count": 0,
            "follower_count": 0
        }
    }
    ```

#### C. 头像上传 (Avatar Upload)
*   **URL**: `POST /api/user/avatar`
*   **Headers**: `Authorization: Bearer ...`
*   **Format**: `Multipart/Form-Data` (Key: "file", Value: 二进制文件)
*   **Response**: 包含新的 CDN 头像地址，需立即刷新 UI。

---

### 3.2 视频流模块 (Feeds) —— *最核心部分*

客户端需实现一个通用的 `VideoListModel`，根据不同的 **Type** 请求不同的 URL。所有 Feed 接口返回的数据结构完全一致。

#### 通用数据结构 (Video Entity)
```json
{
    "id": "v-uuid",
    "title": "My Cat",
    "url": "http://PC-3:8001/public/videos/v-uuid/index.m3u8", // HLS 流地址
    "cover_url": "http://PC-3:8001/public/covers/v-uuid.jpg",
    "duration": 15,
    "like_count": 100,
    "author": "Alice",
    "author_avatar": "http://PC-3:8001/...",
    "is_liked": true,    // 关键：控制点赞红心状态
    "is_followed": false // 关键：控制关注按钮状态
}
```

#### 四种 Feed 场景

| 场景 | 接口 Endpoint | 参数 | 鉴权要求 | 业务逻辑 |
| :--- | :--- | :--- | :--- | :--- |
| **发现页** (推荐) | `GET /api/feed/discovery` | `limit=10`<br>`offset=0` | 可选 | 游客可见。offset=0 时走 Redis 缓存，速度极快。 |
| **关注页** | `GET /api/feed/following` | 同上 | **必须** | 只看我关注的人的视频。未登录直接跳登录页。 |
| **喜欢页** (Likes) | `GET /api/feed/likes` | `user_id={id}`<br>`limit`... | 可选 | 不传 user_id 看自己(需登录)；传 user_id 看别人(游客可看)。 |
| **作品页** (User) | `GET /api/feed/user` | `user_id={id}`<br>`limit`... | 可选 | 同上。展示用户发布的视频列表。 |

> **分页逻辑**:
> 服务端返回 JSON 包含 `"next_offset": 20`。
> 客户端收到响应后，若 `next_offset` > 当前offset，说明还有数据。
> 触底加载时，使用 `next_offset` 作为下一次请求的 `offset` 参数。若返回 0，说明到底了。

---

### 3.3 视频发布全链路 (The Upload Pipeline)

这是跨越三个服务的复杂流程，请严格按步骤执行。

#### 阶段一：源站直传 (Client -> PC-1)
*   **目的**: 绕过网关，将大文件直接写入 MinIO 的临时桶。
*   **生成 UUID**: 客户端生成 UUID (例如 `abc-123`)。
*   **构造 URL**: `http://{PC1_IP}:9000/temp/abc-123.mp4`
*   **Method**: `PUT`
*   **Headers**: `Content-Type: video/mp4`
*   **Body**: 文件的原始二进制数据 (QFile open ReadOnly)。
*   **Qt 示例**:
    ```cpp
    // 不要用 QHttpMultiPart，直接传 Device
    QNetworkRequest request(QUrl("http://192.168.1.10:9000/temp/abc-123.mp4"));
    request.setHeader(QNetworkRequest::ContentTypeHeader, "video/mp4");
    
    QFile *file = new QFile("local_path.mp4");
    file->open(QIODevice::ReadOnly);
    
    QNetworkReply *reply = manager->put(request, file);
    // 务必监听 uploadProgress 更新 UI 进度条
    ```

#### 阶段二：提交任务 (Client -> PC-2)
仅当阶段一返回 **HTTP 200 OK** 后执行。

*   **URL**: `POST /api/video/publish`
*   **Headers**: `Authorization: Bearer ...`
*   **Body**:
    ```json
    {
        "title": "视频标题",
        // 必须是阶段一使用的完整 URL，服务端 Worker 会根据这个 URL 去下载
        "url": "http://192.168.1.10:9000/temp/abc-123.mp4" 
    }
    ```
*   **Response**: `200 OK`。此时视频进入“处理中”状态，客户端提示用户“发布成功，正在转码”即可。

---

### 3.4 社交操作 (Actions)

#### A. 点赞 (Like)
*   **URL**: `POST /api/video/like`
*   **Body**: `{ "video_id": "...", "action": true }` (true=点赞, false=取消)
*   **响应**: `{"code": 200, "like_count": 123}`
*   **客户端策略**: 采用**乐观更新**。点击立刻变红，如果网络请求失败（非200），再变回白色并弹窗报错。使用服务端返回的 `like_count` 修正本地显示。

#### B. 关注 (Follow)
*   **URL**: `POST /api/user/follow`
*   **Body**: `{ "target_id": "...", "action": true }`
*   **响应**: `200 OK`
*   **客户端策略**: 同上，乐观更新。

---

## 4. Qt/QML 架构建议

### 4.1 网络层封装 (`NetworkClient`)
创建一个单例类，统一管理 Request。

```cpp
// 伪代码
void NetworkClient::sendRequest(const QString &endpoint, Method method, const QJsonObject &data, Callback cb) {
    // 1. 拼接 Base URL (根据 endpoint 前缀判断是去 API 还是 CDN)
    // 2. 自动注入 Authorization Header (从 UserContext 读取)
    // 3. 处理 reply 信号
    // 4. 统一拦截 401 错误 -> 发射 sigTokenExpired 信号 -> 界面弹窗跳登录
}
```

### 4.2 播放器优化 (`FeedView`)
*   **MVD 模式**: 使用 `ListView` + `QAbstractListModel`。
*   **资源回收**:
    *   **Delegate**: 只有当前屏幕可见的 item (`ListView.isCurrentItem`) 才加载 `MediaPlayer` 和 `VideoOutput`。
    *   **非当前项**: 销毁播放器，仅显示 `Image` (加载 `cover_url`)。
    *   **预加载**: 这是一个高级功能，考虑到 PC-3 是 Nginx，可以在空闲时预请求下一个视频的 m3u8，利用 Nginx 的 HTTP 缓存特性。

### 4.3 播放地址处理
服务端返回的 URL 是 HLS 格式 (`.m3u8`)。
*   **Qt 6.5+ (FFmpeg backend)**: 原生支持 m3u8。
*   **PC 端开发**: 确保开发机安装了 FFmpeg 库或 LAV Filters (Windows)，否则 QtMultimedia 可能无法解码。
*   **调试**: 如果播放失败，把 URL 复制到浏览器或 VLC 中测试。如果 VLC 能播 Qt 不能播，是 Qt 环境问题；如果 VLC 不能播，是服务端转码问题。

---

## 5. 故障排查手册 (Troubleshooting)

| 现象 | 可能原因 | 排查步骤 |
| :--- | :--- | :--- |
| **登录提示 401** | Token 过期或未发送 | 检查 Request Header 是否包含 `Authorization: Bearer <token>` |
| **视频列表为空** | 数据库无数据或连接失败 | 检查服务端日志 `Server Log`，确认 DB 连接正常；检查 `offset` 参数 |
| **视频画面黑屏** | 解码器缺失或 CDN 不通 | 1. 检查 `ffplay URL` 是否能播<br>2. 检查 PC-3 的 Nginx 容器是否运行<br>3. 检查 PC-3 的防火墙端口 8001 |
| **发布视频一直 0%** | 无法连接 MinIO | 检查客户端 `config.json` 中 PC-1 的 IP 是否正确；Ping PC-1 9000 端口 |
| **发布后刷不到视频** | Worker 转码失败 | 检查 PC-3 的 Worker 日志；可能是 FFmpeg 缺失或 MinIO 网络不通 |
| **点赞/关注 409** | 重复操作 | 正常现象，无需报错，只需同步 UI 状态即可 |

---

# 乐拍视界客户端指南 · 附录：头像与静态资源处理

**核心问题**: 解决绝对路径 (`http://...`) 与相对路径 (`/public/...`) 混用的兼容性问题，以及缓存刷新策略。

---

## 1. 路径解析策略 (Path Resolution Strategy)

服务端返回的 `avatar_url` 字段可能存在两种格式，客户端 **必须** 在 `UserContext` 或 `ConfigManager` 中实现统一的解析函数。

### 1.1 两种数据格式
1.  **绝对路径 (Absolute)**:
    *   格式: `http://192.168.1.12:8001/public/avatars/u123.jpg`
    *   来源: 用户手动上传的头像（由 `UserService` 生成并写入 DB）。
2.  **相对路径 (Relative)**:
    *   格式: `/public/defaults/default.png`
    *   来源: 用户刚注册时的默认头像（由数据库 `DEFAULT` 值定义）。

### 1.2 客户端解析逻辑 (C++ 实现建议)
请在客户端封装一个 helper 函数，用于处理所有图片 URL。

```cpp
// Utils.h 或 ConfigManager.h

/**
 * @brief 将服务端返回的 url 转换为可加载的完整 URL
 * @param rawUrl 服务端 JSON 返回的原始字符串
 * @return QUrl 用于 QML Image source
 */
QUrl resolveImageUrl(const QString &rawUrl) {
    // 1. 如果为空，返回本地占位图 (资源文件)
    if (rawUrl.isEmpty()) {
        return QUrl("qrc:/assets/placeholder.png");
    }

    // 2. 如果已经是 HTTP/HTTPS 开头，直接使用
    if (rawUrl.startsWith("http://") || rawUrl.startsWith("https://")) {
        return QUrl(rawUrl);
    }

    // 3. 如果是相对路径，拼接 config.json 中的 cdn_base
    // 假设 ConfigManager::instance().cdnBase() 返回 "http://192.168.1.12:8001"
    QString baseUrl = ConfigManager::instance().cdnBase();
    
    // 处理斜杠拼接，防止出现 "http://...8001/public" 或 "http://...8001//public"
    if (baseUrl.endsWith("/")) baseUrl.chop(1);
    QString path = rawUrl;
    if (!path.startsWith("/")) path.prepend("/");

    return QUrl(baseUrl + path);
}
```

---

## 2. 头像上传与更新 (Upload & Refresh)

与视频上传（直传 MinIO）不同，**头像上传必须经过 API 网关**，因为需要服务端进行图片处理、数据库更新以及缓存失效通知。

### 2.1 上传流程
*   **API**: `POST /api/user/avatar`
*   **Format**: `multipart/form-data`
*   **Qt 实现细节**:

```cpp
// AvatarUploadTask.cpp

void uploadAvatar(const QString &filePath) {
    // 准备请求
    QNetworkRequest request(QUrl(ConfigManager::instance().apiBase() + "/api/user/avatar"));
    QString token = UserContext::instance().token();
    request.setRawHeader("Authorization", ("Bearer " + token).toUtf8());

    // 构建 Multipart
    QHttpMultiPart *multiPart = new QHttpMultiPart(QHttpMultiPart::FormDataType);

    QHttpPart imagePart;
    // 告知服务端这是个文件，且 key 必须是 "file" (对应服务端 drogon::MultiPartParser)
    imagePart.setHeader(QNetworkRequest::ContentDispositionHeader, 
                        QVariant("form-data; name=\"file\"; filename=\"avatar.jpg\""));
    imagePart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("image/jpeg"));

    QFile *file = new QFile(filePath);
    file->open(QIODevice::ReadOnly);
    imagePart.setBodyDevice(file);
    file->setParent(multiPart); // 随 multiPart 一起销毁

    multiPart->append(imagePart);

    // 发送
    QNetworkReply *reply = manager->post(request, multiPart);
    multiPart->setParent(reply); // 随 reply 一起销毁

    // 处理响应
    connect(reply, &QNetworkReply::finished, [=](){
        if (reply->error() == QNetworkReply::NoError) {
            QByteArray respData = reply->readAll();
            // 解析 JSON，取出 "avatar_url"
            // 更新本地 UserContext
            // 关键：触发 UI 刷新
        }
    });
}
```

### 2.2 缓存与刷新 (Cache Busting)

**痛点**: 服务端保存头像通常使用 `userID.jpg` 作为文件名。当你修改头像再次上传时，文件名不变，URL 也不变。
*   **问题**: CDN (Nginx) 会缓存旧图片，Qt `QNetworkAccessManager` 也会缓存旧图片。用户上传后看到的还是旧头像。
*   **解决方案**: **客户端手动添加时间戳**。

**UI 绑定策略 (QML)**:

当上传成功，拿到新的 URL（或者即使 URL 字符串没变）时，在赋值给 QML `Image.source` 之前，强制追加一个随机参数。

```qml
// UserProfile.qml

Image {
    id: avatarImg
    // userContext.avatarUrl 来自 C++ 模型
    // timestamp 是一个局部变量，上传成功后更新它，例如 Date.now()
    source: resolveImageUrl(userContext.avatarUrl) + "?t=" + timestamp
    
    cache: false // 建议上传页面的预览图关闭缓存，或者利用上述的时间戳大法
    fillMode: Image.PreserveAspectCrop
    layer.enabled: true
    layer.effect: OpacityMask { ... } // 圆形遮罩
}

// Javascript function called after upload success:
function onUploadSuccess(newUrl) {
    userContext.avatarUrl = newUrl; 
    timestamp = Date.now(); // 强制 Image 组件重新请求网络
}
```

---

## 3. 常见问题排查

| 现象 | 原因分析 | 解决方案 |
| :--- | :--- | :--- |
| **头像显示破损图标** | 1. 相对路径未拼接 Base URL<br>2. Base URL 配置错误 (IP 变了) | 检查 `config.json` 中的 `cdn_base`；检查是否使用了 `resolveImageUrl` 函数。 |
| **上传后头像没变** | CDN 或本地缓存了旧图 | 在 URL 后追加 `?t=当前时间戳` 强制刷新。 |
| **上传失败 (400)** | Multipart 组包错误 | 确保 Part 的 name 属性是 `file` (`name="file"`)，这是后端硬编码识别的 key。 |
| **默认头像不显示** | MinIO 中没有默认资源 | 确保服务端运行过 `setup_minio_buckets.sh`，且 PC-3 (CDN) 能连通 PC-1 (MinIO)。 |

---

## 4. 总结：客户端头像处理伪代码

```cpp
// 获取 URL (从 UserContext 或 Feed 列表)
QString rawUrl = item.avatar_url; 

// 标准化 (处理相对路径)
QString fullUrl = ConfigManager::resolve(rawUrl);

// (仅在显示当前用户头像且刚上传完时) 破除缓存
if (isCurrentUser && justUploaded) {
    fullUrl += QString("?t=%1").arg(QDateTime::currentMSecsSinceEpoch());
}

// 赋值给 QML
emit avatarChanged(fullUrl);
```